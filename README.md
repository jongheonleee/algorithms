# algorithms

알고리즘에서 중요한 능력은 추상화와 순간 집중력인거같다
<br/>
인지적 한계로 인해 알고리즘의 동작 과정을 세세하게 관찰하는 것은 불가능함
<br/>
따라서 알고리즘의 변하지 않는 본질과 핵심 아이디어를 추상화하여 머리속에 체계적으로 정리해 놓아야 한다
<br/>
이를 통해 알고리즘 문제를 풀어나가는 데 있어서 추상화 능력을 바탕으로 기초 발상을 할 줄 알아야할 것 같다
<br/>
또한, 알고리즘 문제를 풀다 보면 결국엔 구현과정에서는 최대한 집중을 해서 정확도를 길러야 한다. 
<br/>
이때 특정 알고리즘을 작성하는 패턴들은 기본적으로 암기가 되어 있는 상태여야 빠르고 정확하게 풀어갈 수 있는 것 같다

## 내가 학습해야 할 것들

### 1. 알고리즘 본질 및 핵심 아이디어 추상화하기와 머리속에 체계적으로 정리해 놓기 -> 알고리즘 문제 풀면서 해당 알고리즘을 나만의 언어로 완전 이해하고 정리하기
### 2. 반복되는 구현 패턴에 익숙해지기 -> 알고리즘 기초 구현 암기
### 3. 순간 집중력 -> 문제 많이 풀어보기

<br/>

## 알고리즘 추상화(나만의 언어로 정리 및 그림 그리기)

### 🎯 Search
- binary search : 정렬된 배열에서 절반씩 탐색 범위를 줄여나가면서 특정 값을 빠르게 찾는 알고리즘, O(N * log N), 이분탐색의 경우 최적해를 찾기 어렵지만 정답의 범위를 탐색할 수 있는 경우(Yes/No) 문제에서 활용할 수 있음 예를 들어 내 키는 몇 센치인가라고 질문했을 때, 정확한 답은 안해주고 up/down만 말해주는 경우, nnnnnnn<b>y</b>yyyy 첫번째 y가 최적해임
                  
  - lower bound : 이분 탐색을 기반으로 찾고자 하는 값에서 가장 왼쪽에 위치한 값을 찾음, 이때 pos = mid로 참조시켜줌
  - upper bound : 마찬가지로 이분 탐색 알고리즘을 기반으로 찾고자 하는 값보다 큰 값 중에서 바로 오른쪽에 위치한 값을 찾음
    - 예를 들어서 [1, 2, 2, 2, 3 ,,,] upper_bound(2) -> 3's index = 4 
 

### 🎹 Sort
- merge sort : 큰 덩어리를 중심을 기준으로 왼쪽, 오른쪽으로 나누고 이 과정을 가장 기본 단위가 될 때까지 진행한 다음에 차근차근 정렬하면서 합쳐줌, O(N * logN)
- quick sort : 머지 소트와 마찬가지로 분할 정복 알고리즘으로써, 피벗을 기준으로 left는 피벗보다 작은 거, right는 피벗보다 큰 거로 나눠줌, 최악의 경우 O(N^2)가 나오므로 shuffle()을 통해 저격 데이터를 적절히 섞어주는 것이 좋음

